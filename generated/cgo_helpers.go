// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Sun, 04 May 2025 20:28:02 BST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package generated

/*
#cgo LDFLAGS: -L/usr/lib -lrkllmrt
#include "types.h"
#include "rkllm.h"
#include "rkllm_input_wrappers.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocRKLLMExtendParamMemory allocates memory for type C.RKLLMExtendParam in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRKLLMExtendParamMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRKLLMExtendParamValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRKLLMExtendParamValue = unsafe.Sizeof([1]C.RKLLMExtendParam{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RKLLMExtendParam) Ref() *C.RKLLMExtendParam {
	if x == nil {
		return nil
	}
	return x.refc9ca11e0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RKLLMExtendParam) Free() {
	if x != nil && x.allocsc9ca11e0 != nil {
		x.allocsc9ca11e0.(*cgoAllocMap).Free()
		x.refc9ca11e0 = nil
	}
}

// NewRKLLMExtendParamRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRKLLMExtendParamRef(ref unsafe.Pointer) *RKLLMExtendParam {
	if ref == nil {
		return nil
	}
	obj := new(RKLLMExtendParam)
	obj.refc9ca11e0 = (*C.RKLLMExtendParam)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RKLLMExtendParam) PassRef() (*C.RKLLMExtendParam, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc9ca11e0 != nil {
		return x.refc9ca11e0, nil
	}
	memc9ca11e0 := allocRKLLMExtendParamMemory(1)
	refc9ca11e0 := (*C.RKLLMExtendParam)(memc9ca11e0)
	allocsc9ca11e0 := new(cgoAllocMap)
	allocsc9ca11e0.Add(memc9ca11e0)

	var cbase_domain_id_allocs *cgoAllocMap
	refc9ca11e0.base_domain_id, cbase_domain_id_allocs = (C.int32_t)(x.Base_domain_id), cgoAllocsUnknown
	allocsc9ca11e0.Borrow(cbase_domain_id_allocs)

	var cembed_flash_allocs *cgoAllocMap
	refc9ca11e0.embed_flash, cembed_flash_allocs = (C.int8_t)(x.Embed_flash), cgoAllocsUnknown
	allocsc9ca11e0.Borrow(cembed_flash_allocs)

	var cenabled_cpus_num_allocs *cgoAllocMap
	refc9ca11e0.enabled_cpus_num, cenabled_cpus_num_allocs = (C.int8_t)(x.Enabled_cpus_num), cgoAllocsUnknown
	allocsc9ca11e0.Borrow(cenabled_cpus_num_allocs)

	var cenabled_cpus_mask_allocs *cgoAllocMap
	refc9ca11e0.enabled_cpus_mask, cenabled_cpus_mask_allocs = (C.uint32_t)(x.Enabled_cpus_mask), cgoAllocsUnknown
	allocsc9ca11e0.Borrow(cenabled_cpus_mask_allocs)

	var creserved_allocs *cgoAllocMap
	refc9ca11e0.reserved, creserved_allocs = *(*[106]C.uint8_t)(unsafe.Pointer(&x.Reserved)), cgoAllocsUnknown
	allocsc9ca11e0.Borrow(creserved_allocs)

	x.refc9ca11e0 = refc9ca11e0
	x.allocsc9ca11e0 = allocsc9ca11e0
	return refc9ca11e0, allocsc9ca11e0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RKLLMExtendParam) PassValue() (C.RKLLMExtendParam, *cgoAllocMap) {
	if x.refc9ca11e0 != nil {
		return *x.refc9ca11e0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RKLLMExtendParam) Deref() {
	if x.refc9ca11e0 == nil {
		return
	}
	x.Base_domain_id = (int32)(x.refc9ca11e0.base_domain_id)
	x.Embed_flash = (int8)(x.refc9ca11e0.embed_flash)
	x.Enabled_cpus_num = (int8)(x.refc9ca11e0.enabled_cpus_num)
	x.Enabled_cpus_mask = (uint32)(x.refc9ca11e0.enabled_cpus_mask)
	x.Reserved = *(*[106]byte)(unsafe.Pointer(&x.refc9ca11e0.reserved))
}

// allocRKLLMParamMemory allocates memory for type C.RKLLMParam in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRKLLMParamMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRKLLMParamValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRKLLMParamValue = unsafe.Sizeof([1]C.RKLLMParam{})

// copyPCharBytes copies the data from Go slice as *C.char.
func copyPCharBytes(slice *sliceHeader) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfCharValue) * slice.Len,
		Cap:  int(sizeOfCharValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.char)(mem0), allocs
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocCharMemory allocates memory for type C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCharValue = unsafe.Sizeof([1]C.char{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RKLLMParam) Ref() *C.RKLLMParam {
	if x == nil {
		return nil
	}
	return x.refefead654
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RKLLMParam) Free() {
	if x != nil && x.allocsefead654 != nil {
		x.allocsefead654.(*cgoAllocMap).Free()
		x.refefead654 = nil
	}
}

// NewRKLLMParamRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRKLLMParamRef(ref unsafe.Pointer) *RKLLMParam {
	if ref == nil {
		return nil
	}
	obj := new(RKLLMParam)
	obj.refefead654 = (*C.RKLLMParam)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RKLLMParam) PassRef() (*C.RKLLMParam, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refefead654 != nil {
		return x.refefead654, nil
	}
	memefead654 := allocRKLLMParamMemory(1)
	refefead654 := (*C.RKLLMParam)(memefead654)
	allocsefead654 := new(cgoAllocMap)
	allocsefead654.Add(memefead654)

	var cmodel_path_allocs *cgoAllocMap
	refefead654.model_path, cmodel_path_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.Model_path)))
	allocsefead654.Borrow(cmodel_path_allocs)

	var cmax_context_len_allocs *cgoAllocMap
	refefead654.max_context_len, cmax_context_len_allocs = (C.int32_t)(x.Max_context_len), cgoAllocsUnknown
	allocsefead654.Borrow(cmax_context_len_allocs)

	var cmax_new_tokens_allocs *cgoAllocMap
	refefead654.max_new_tokens, cmax_new_tokens_allocs = (C.int32_t)(x.Max_new_tokens), cgoAllocsUnknown
	allocsefead654.Borrow(cmax_new_tokens_allocs)

	var ctop_k_allocs *cgoAllocMap
	refefead654.top_k, ctop_k_allocs = (C.int32_t)(x.Top_k), cgoAllocsUnknown
	allocsefead654.Borrow(ctop_k_allocs)

	var cn_keep_allocs *cgoAllocMap
	refefead654.n_keep, cn_keep_allocs = (C.int32_t)(x.N_keep), cgoAllocsUnknown
	allocsefead654.Borrow(cn_keep_allocs)

	var ctop_p_allocs *cgoAllocMap
	refefead654.top_p, ctop_p_allocs = (C.float)(x.Top_p), cgoAllocsUnknown
	allocsefead654.Borrow(ctop_p_allocs)

	var ctemperature_allocs *cgoAllocMap
	refefead654.temperature, ctemperature_allocs = (C.float)(x.Temperature), cgoAllocsUnknown
	allocsefead654.Borrow(ctemperature_allocs)

	var crepeat_penalty_allocs *cgoAllocMap
	refefead654.repeat_penalty, crepeat_penalty_allocs = (C.float)(x.Repeat_penalty), cgoAllocsUnknown
	allocsefead654.Borrow(crepeat_penalty_allocs)

	var cfrequency_penalty_allocs *cgoAllocMap
	refefead654.frequency_penalty, cfrequency_penalty_allocs = (C.float)(x.Frequency_penalty), cgoAllocsUnknown
	allocsefead654.Borrow(cfrequency_penalty_allocs)

	var cpresence_penalty_allocs *cgoAllocMap
	refefead654.presence_penalty, cpresence_penalty_allocs = (C.float)(x.Presence_penalty), cgoAllocsUnknown
	allocsefead654.Borrow(cpresence_penalty_allocs)

	var cmirostat_allocs *cgoAllocMap
	refefead654.mirostat, cmirostat_allocs = (C.int32_t)(x.Mirostat), cgoAllocsUnknown
	allocsefead654.Borrow(cmirostat_allocs)

	var cmirostat_tau_allocs *cgoAllocMap
	refefead654.mirostat_tau, cmirostat_tau_allocs = (C.float)(x.Mirostat_tau), cgoAllocsUnknown
	allocsefead654.Borrow(cmirostat_tau_allocs)

	var cmirostat_eta_allocs *cgoAllocMap
	refefead654.mirostat_eta, cmirostat_eta_allocs = (C.float)(x.Mirostat_eta), cgoAllocsUnknown
	allocsefead654.Borrow(cmirostat_eta_allocs)

	var cskip_special_token_allocs *cgoAllocMap
	refefead654.skip_special_token, cskip_special_token_allocs = (C.bool)(x.Skip_special_token), cgoAllocsUnknown
	allocsefead654.Borrow(cskip_special_token_allocs)

	var cis_async_allocs *cgoAllocMap
	refefead654.is_async, cis_async_allocs = (C.bool)(x.Is_async), cgoAllocsUnknown
	allocsefead654.Borrow(cis_async_allocs)

	var cimg_start_allocs *cgoAllocMap
	refefead654.img_start, cimg_start_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.Img_start)))
	allocsefead654.Borrow(cimg_start_allocs)

	var cimg_end_allocs *cgoAllocMap
	refefead654.img_end, cimg_end_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.Img_end)))
	allocsefead654.Borrow(cimg_end_allocs)

	var cimg_content_allocs *cgoAllocMap
	refefead654.img_content, cimg_content_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.Img_content)))
	allocsefead654.Borrow(cimg_content_allocs)

	var cextend_param_allocs *cgoAllocMap
	refefead654.extend_param, cextend_param_allocs = x.Extend_param.PassValue()
	allocsefead654.Borrow(cextend_param_allocs)

	x.refefead654 = refefead654
	x.allocsefead654 = allocsefead654
	return refefead654, allocsefead654

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RKLLMParam) PassValue() (C.RKLLMParam, *cgoAllocMap) {
	if x.refefead654 != nil {
		return *x.refefead654, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RKLLMParam) Deref() {
	if x.refefead654 == nil {
		return
	}
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.Model_path))
	hxfc4425b.Data = unsafe.Pointer(x.refefead654.model_path)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ? x.Model_path x.refefead654.model_path

	x.Max_context_len = (int32)(x.refefead654.max_context_len)
	x.Max_new_tokens = (int32)(x.refefead654.max_new_tokens)
	x.Top_k = (int32)(x.refefead654.top_k)
	x.N_keep = (int32)(x.refefead654.n_keep)
	x.Top_p = (float32)(x.refefead654.top_p)
	x.Temperature = (float32)(x.refefead654.temperature)
	x.Repeat_penalty = (float32)(x.refefead654.repeat_penalty)
	x.Frequency_penalty = (float32)(x.refefead654.frequency_penalty)
	x.Presence_penalty = (float32)(x.refefead654.presence_penalty)
	x.Mirostat = (int32)(x.refefead654.mirostat)
	x.Mirostat_tau = (float32)(x.refefead654.mirostat_tau)
	x.Mirostat_eta = (float32)(x.refefead654.mirostat_eta)
	x.Skip_special_token = (bool)(x.refefead654.skip_special_token)
	x.Is_async = (bool)(x.refefead654.is_async)
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.Img_start))
	hxf95e7c8.Data = unsafe.Pointer(x.refefead654.img_start)
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ? x.Img_start x.refefead654.img_start

	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.Img_end))
	hxff2234b.Data = unsafe.Pointer(x.refefead654.img_end)
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ? x.Img_end x.refefead654.img_end

	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.Img_content))
	hxff73280.Data = unsafe.Pointer(x.refefead654.img_content)
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ? x.Img_content x.refefead654.img_content

	x.Extend_param = *NewRKLLMExtendParamRef(unsafe.Pointer(&x.refefead654.extend_param))
}

// allocRKLLMLoraAdapterMemory allocates memory for type C.RKLLMLoraAdapter in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRKLLMLoraAdapterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRKLLMLoraAdapterValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRKLLMLoraAdapterValue = unsafe.Sizeof([1]C.RKLLMLoraAdapter{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RKLLMLoraAdapter) Ref() *C.RKLLMLoraAdapter {
	if x == nil {
		return nil
	}
	return x.ref205d9e7e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RKLLMLoraAdapter) Free() {
	if x != nil && x.allocs205d9e7e != nil {
		x.allocs205d9e7e.(*cgoAllocMap).Free()
		x.ref205d9e7e = nil
	}
}

// NewRKLLMLoraAdapterRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRKLLMLoraAdapterRef(ref unsafe.Pointer) *RKLLMLoraAdapter {
	if ref == nil {
		return nil
	}
	obj := new(RKLLMLoraAdapter)
	obj.ref205d9e7e = (*C.RKLLMLoraAdapter)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RKLLMLoraAdapter) PassRef() (*C.RKLLMLoraAdapter, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref205d9e7e != nil {
		return x.ref205d9e7e, nil
	}
	mem205d9e7e := allocRKLLMLoraAdapterMemory(1)
	ref205d9e7e := (*C.RKLLMLoraAdapter)(mem205d9e7e)
	allocs205d9e7e := new(cgoAllocMap)
	allocs205d9e7e.Add(mem205d9e7e)

	var clora_adapter_path_allocs *cgoAllocMap
	ref205d9e7e.lora_adapter_path, clora_adapter_path_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.Lora_adapter_path)))
	allocs205d9e7e.Borrow(clora_adapter_path_allocs)

	var clora_adapter_name_allocs *cgoAllocMap
	ref205d9e7e.lora_adapter_name, clora_adapter_name_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.Lora_adapter_name)))
	allocs205d9e7e.Borrow(clora_adapter_name_allocs)

	var cscale_allocs *cgoAllocMap
	ref205d9e7e.scale, cscale_allocs = (C.float)(x.Scale), cgoAllocsUnknown
	allocs205d9e7e.Borrow(cscale_allocs)

	x.ref205d9e7e = ref205d9e7e
	x.allocs205d9e7e = allocs205d9e7e
	return ref205d9e7e, allocs205d9e7e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RKLLMLoraAdapter) PassValue() (C.RKLLMLoraAdapter, *cgoAllocMap) {
	if x.ref205d9e7e != nil {
		return *x.ref205d9e7e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RKLLMLoraAdapter) Deref() {
	if x.ref205d9e7e == nil {
		return
	}
	hxfa9955c := (*sliceHeader)(unsafe.Pointer(&x.Lora_adapter_path))
	hxfa9955c.Data = unsafe.Pointer(x.ref205d9e7e.lora_adapter_path)
	hxfa9955c.Cap = 0x7fffffff
	// hxfa9955c.Len = ? x.Lora_adapter_path x.ref205d9e7e.lora_adapter_path

	hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&x.Lora_adapter_name))
	hxfa3f05c.Data = unsafe.Pointer(x.ref205d9e7e.lora_adapter_name)
	hxfa3f05c.Cap = 0x7fffffff
	// hxfa3f05c.Len = ? x.Lora_adapter_name x.ref205d9e7e.lora_adapter_name

	x.Scale = (float32)(x.ref205d9e7e.scale)
}

// allocRKLLMEmbedInputMemory allocates memory for type C.RKLLMEmbedInput in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRKLLMEmbedInputMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRKLLMEmbedInputValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRKLLMEmbedInputValue = unsafe.Sizeof([1]C.RKLLMEmbedInput{})

// copyPFloatBytes copies the data from Go slice as *C.float.
func copyPFloatBytes(slice *sliceHeader) (*C.float, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfFloatValue) * slice.Len,
		Cap:  int(sizeOfFloatValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.float)(mem0), allocs
}

// allocFloatMemory allocates memory for type C.float in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFloatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFloatValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFloatValue = unsafe.Sizeof([1]C.float{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RKLLMEmbedInput) Ref() *C.RKLLMEmbedInput {
	if x == nil {
		return nil
	}
	return x.ref229ed580
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RKLLMEmbedInput) Free() {
	if x != nil && x.allocs229ed580 != nil {
		x.allocs229ed580.(*cgoAllocMap).Free()
		x.ref229ed580 = nil
	}
}

// NewRKLLMEmbedInputRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRKLLMEmbedInputRef(ref unsafe.Pointer) *RKLLMEmbedInput {
	if ref == nil {
		return nil
	}
	obj := new(RKLLMEmbedInput)
	obj.ref229ed580 = (*C.RKLLMEmbedInput)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RKLLMEmbedInput) PassRef() (*C.RKLLMEmbedInput, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref229ed580 != nil {
		return x.ref229ed580, nil
	}
	mem229ed580 := allocRKLLMEmbedInputMemory(1)
	ref229ed580 := (*C.RKLLMEmbedInput)(mem229ed580)
	allocs229ed580 := new(cgoAllocMap)
	allocs229ed580.Add(mem229ed580)

	var cembed_allocs *cgoAllocMap
	ref229ed580.embed, cembed_allocs = copyPFloatBytes((*sliceHeader)(unsafe.Pointer(&x.Embed)))
	allocs229ed580.Borrow(cembed_allocs)

	var cn_tokens_allocs *cgoAllocMap
	ref229ed580.n_tokens, cn_tokens_allocs = (C.size_t)(x.N_tokens), cgoAllocsUnknown
	allocs229ed580.Borrow(cn_tokens_allocs)

	x.ref229ed580 = ref229ed580
	x.allocs229ed580 = allocs229ed580
	return ref229ed580, allocs229ed580

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RKLLMEmbedInput) PassValue() (C.RKLLMEmbedInput, *cgoAllocMap) {
	if x.ref229ed580 != nil {
		return *x.ref229ed580, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RKLLMEmbedInput) Deref() {
	if x.ref229ed580 == nil {
		return
	}
	hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&x.Embed))
	hxf0d18b7.Data = unsafe.Pointer(x.ref229ed580.embed)
	hxf0d18b7.Cap = 0x7fffffff
	// hxf0d18b7.Len = ? x.Embed x.ref229ed580.embed

	x.N_tokens = (uint64)(x.ref229ed580.n_tokens)
}

// allocRKLLMTokenInputMemory allocates memory for type C.RKLLMTokenInput in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRKLLMTokenInputMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRKLLMTokenInputValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRKLLMTokenInputValue = unsafe.Sizeof([1]C.RKLLMTokenInput{})

// copyPInt32_tBytes copies the data from Go slice as *C.int32_t.
func copyPInt32_tBytes(slice *sliceHeader) (*C.int32_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfInt32_tValue) * slice.Len,
		Cap:  int(sizeOfInt32_tValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.int32_t)(mem0), allocs
}

// allocInt32_tMemory allocates memory for type C.int32_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInt32_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInt32_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfInt32_tValue = unsafe.Sizeof([1]C.int32_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RKLLMTokenInput) Ref() *C.RKLLMTokenInput {
	if x == nil {
		return nil
	}
	return x.ref7ad02f9d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RKLLMTokenInput) Free() {
	if x != nil && x.allocs7ad02f9d != nil {
		x.allocs7ad02f9d.(*cgoAllocMap).Free()
		x.ref7ad02f9d = nil
	}
}

// NewRKLLMTokenInputRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRKLLMTokenInputRef(ref unsafe.Pointer) *RKLLMTokenInput {
	if ref == nil {
		return nil
	}
	obj := new(RKLLMTokenInput)
	obj.ref7ad02f9d = (*C.RKLLMTokenInput)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RKLLMTokenInput) PassRef() (*C.RKLLMTokenInput, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7ad02f9d != nil {
		return x.ref7ad02f9d, nil
	}
	mem7ad02f9d := allocRKLLMTokenInputMemory(1)
	ref7ad02f9d := (*C.RKLLMTokenInput)(mem7ad02f9d)
	allocs7ad02f9d := new(cgoAllocMap)
	allocs7ad02f9d.Add(mem7ad02f9d)

	var cinput_ids_allocs *cgoAllocMap
	ref7ad02f9d.input_ids, cinput_ids_allocs = copyPInt32_tBytes((*sliceHeader)(unsafe.Pointer(&x.Input_ids)))
	allocs7ad02f9d.Borrow(cinput_ids_allocs)

	var cn_tokens_allocs *cgoAllocMap
	ref7ad02f9d.n_tokens, cn_tokens_allocs = (C.size_t)(x.N_tokens), cgoAllocsUnknown
	allocs7ad02f9d.Borrow(cn_tokens_allocs)

	x.ref7ad02f9d = ref7ad02f9d
	x.allocs7ad02f9d = allocs7ad02f9d
	return ref7ad02f9d, allocs7ad02f9d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RKLLMTokenInput) PassValue() (C.RKLLMTokenInput, *cgoAllocMap) {
	if x.ref7ad02f9d != nil {
		return *x.ref7ad02f9d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RKLLMTokenInput) Deref() {
	if x.ref7ad02f9d == nil {
		return
	}
	hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&x.Input_ids))
	hxf2fab0d.Data = unsafe.Pointer(x.ref7ad02f9d.input_ids)
	hxf2fab0d.Cap = 0x7fffffff
	// hxf2fab0d.Len = ? x.Input_ids x.ref7ad02f9d.input_ids

	x.N_tokens = (uint64)(x.ref7ad02f9d.n_tokens)
}

// allocRKLLMMultiModelInputMemory allocates memory for type C.RKLLMMultiModelInput in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRKLLMMultiModelInputMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRKLLMMultiModelInputValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRKLLMMultiModelInputValue = unsafe.Sizeof([1]C.RKLLMMultiModelInput{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RKLLMMultiModelInput) Ref() *C.RKLLMMultiModelInput {
	if x == nil {
		return nil
	}
	return x.refbb2dae19
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RKLLMMultiModelInput) Free() {
	if x != nil && x.allocsbb2dae19 != nil {
		x.allocsbb2dae19.(*cgoAllocMap).Free()
		x.refbb2dae19 = nil
	}
}

// NewRKLLMMultiModelInputRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRKLLMMultiModelInputRef(ref unsafe.Pointer) *RKLLMMultiModelInput {
	if ref == nil {
		return nil
	}
	obj := new(RKLLMMultiModelInput)
	obj.refbb2dae19 = (*C.RKLLMMultiModelInput)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RKLLMMultiModelInput) PassRef() (*C.RKLLMMultiModelInput, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbb2dae19 != nil {
		return x.refbb2dae19, nil
	}
	membb2dae19 := allocRKLLMMultiModelInputMemory(1)
	refbb2dae19 := (*C.RKLLMMultiModelInput)(membb2dae19)
	allocsbb2dae19 := new(cgoAllocMap)
	allocsbb2dae19.Add(membb2dae19)

	var cprompt_allocs *cgoAllocMap
	refbb2dae19.prompt, cprompt_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.Prompt)))
	allocsbb2dae19.Borrow(cprompt_allocs)

	var cimage_embed_allocs *cgoAllocMap
	refbb2dae19.image_embed, cimage_embed_allocs = copyPFloatBytes((*sliceHeader)(unsafe.Pointer(&x.Image_embed)))
	allocsbb2dae19.Borrow(cimage_embed_allocs)

	var cn_image_tokens_allocs *cgoAllocMap
	refbb2dae19.n_image_tokens, cn_image_tokens_allocs = (C.size_t)(x.N_image_tokens), cgoAllocsUnknown
	allocsbb2dae19.Borrow(cn_image_tokens_allocs)

	var cn_image_allocs *cgoAllocMap
	refbb2dae19.n_image, cn_image_allocs = (C.size_t)(x.N_image), cgoAllocsUnknown
	allocsbb2dae19.Borrow(cn_image_allocs)

	var cimage_width_allocs *cgoAllocMap
	refbb2dae19.image_width, cimage_width_allocs = (C.size_t)(x.Image_width), cgoAllocsUnknown
	allocsbb2dae19.Borrow(cimage_width_allocs)

	var cimage_height_allocs *cgoAllocMap
	refbb2dae19.image_height, cimage_height_allocs = (C.size_t)(x.Image_height), cgoAllocsUnknown
	allocsbb2dae19.Borrow(cimage_height_allocs)

	x.refbb2dae19 = refbb2dae19
	x.allocsbb2dae19 = allocsbb2dae19
	return refbb2dae19, allocsbb2dae19

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RKLLMMultiModelInput) PassValue() (C.RKLLMMultiModelInput, *cgoAllocMap) {
	if x.refbb2dae19 != nil {
		return *x.refbb2dae19, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RKLLMMultiModelInput) Deref() {
	if x.refbb2dae19 == nil {
		return
	}
	hxf69fe70 := (*sliceHeader)(unsafe.Pointer(&x.Prompt))
	hxf69fe70.Data = unsafe.Pointer(x.refbb2dae19.prompt)
	hxf69fe70.Cap = 0x7fffffff
	// hxf69fe70.Len = ? x.Prompt x.refbb2dae19.prompt

	hxf65bf54 := (*sliceHeader)(unsafe.Pointer(&x.Image_embed))
	hxf65bf54.Data = unsafe.Pointer(x.refbb2dae19.image_embed)
	hxf65bf54.Cap = 0x7fffffff
	// hxf65bf54.Len = ? x.Image_embed x.refbb2dae19.image_embed

	x.N_image_tokens = (uint64)(x.refbb2dae19.n_image_tokens)
	x.N_image = (uint64)(x.refbb2dae19.n_image)
	x.Image_width = (uint64)(x.refbb2dae19.image_width)
	x.Image_height = (uint64)(x.refbb2dae19.image_height)
}

// allocRKLLMInputMemory allocates memory for type C.RKLLMInput in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRKLLMInputMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRKLLMInputValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRKLLMInputValue = unsafe.Sizeof([1]C.RKLLMInput{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RKLLMInput) Ref() *C.RKLLMInput {
	if x == nil {
		return nil
	}
	return x.ref9338980a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RKLLMInput) Free() {
	if x != nil && x.allocs9338980a != nil {
		x.allocs9338980a.(*cgoAllocMap).Free()
		x.ref9338980a = nil
	}
}

// NewRKLLMInputRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRKLLMInputRef(ref unsafe.Pointer) *RKLLMInput {
	if ref == nil {
		return nil
	}
	obj := new(RKLLMInput)
	obj.ref9338980a = (*C.RKLLMInput)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RKLLMInput) PassRef() (*C.RKLLMInput, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9338980a != nil {
		return x.ref9338980a, nil
	}
	mem9338980a := allocRKLLMInputMemory(1)
	ref9338980a := (*C.RKLLMInput)(mem9338980a)
	allocs9338980a := new(cgoAllocMap)
	allocs9338980a.Add(mem9338980a)

	var cinput_type_allocs *cgoAllocMap
	ref9338980a.input_type, cinput_type_allocs = (C.RKLLMInputType)(x.Input_type), cgoAllocsUnknown
	allocs9338980a.Borrow(cinput_type_allocs)

	x.ref9338980a = ref9338980a
	x.allocs9338980a = allocs9338980a
	return ref9338980a, allocs9338980a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RKLLMInput) PassValue() (C.RKLLMInput, *cgoAllocMap) {
	if x.ref9338980a != nil {
		return *x.ref9338980a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RKLLMInput) Deref() {
	if x.ref9338980a == nil {
		return
	}
	x.Input_type = (RKLLMInputType)(x.ref9338980a.input_type)
}

// allocRKLLMLoraParamMemory allocates memory for type C.RKLLMLoraParam in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRKLLMLoraParamMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRKLLMLoraParamValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRKLLMLoraParamValue = unsafe.Sizeof([1]C.RKLLMLoraParam{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RKLLMLoraParam) Ref() *C.RKLLMLoraParam {
	if x == nil {
		return nil
	}
	return x.refe5ce5edf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RKLLMLoraParam) Free() {
	if x != nil && x.allocse5ce5edf != nil {
		x.allocse5ce5edf.(*cgoAllocMap).Free()
		x.refe5ce5edf = nil
	}
}

// NewRKLLMLoraParamRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRKLLMLoraParamRef(ref unsafe.Pointer) *RKLLMLoraParam {
	if ref == nil {
		return nil
	}
	obj := new(RKLLMLoraParam)
	obj.refe5ce5edf = (*C.RKLLMLoraParam)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RKLLMLoraParam) PassRef() (*C.RKLLMLoraParam, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe5ce5edf != nil {
		return x.refe5ce5edf, nil
	}
	meme5ce5edf := allocRKLLMLoraParamMemory(1)
	refe5ce5edf := (*C.RKLLMLoraParam)(meme5ce5edf)
	allocse5ce5edf := new(cgoAllocMap)
	allocse5ce5edf.Add(meme5ce5edf)

	var clora_adapter_name_allocs *cgoAllocMap
	refe5ce5edf.lora_adapter_name, clora_adapter_name_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.Lora_adapter_name)))
	allocse5ce5edf.Borrow(clora_adapter_name_allocs)

	x.refe5ce5edf = refe5ce5edf
	x.allocse5ce5edf = allocse5ce5edf
	return refe5ce5edf, allocse5ce5edf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RKLLMLoraParam) PassValue() (C.RKLLMLoraParam, *cgoAllocMap) {
	if x.refe5ce5edf != nil {
		return *x.refe5ce5edf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RKLLMLoraParam) Deref() {
	if x.refe5ce5edf == nil {
		return
	}
	hxf3b8dbd := (*sliceHeader)(unsafe.Pointer(&x.Lora_adapter_name))
	hxf3b8dbd.Data = unsafe.Pointer(x.refe5ce5edf.lora_adapter_name)
	hxf3b8dbd.Cap = 0x7fffffff
	// hxf3b8dbd.Len = ? x.Lora_adapter_name x.refe5ce5edf.lora_adapter_name

}

// allocRKLLMPromptCacheParamMemory allocates memory for type C.RKLLMPromptCacheParam in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRKLLMPromptCacheParamMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRKLLMPromptCacheParamValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRKLLMPromptCacheParamValue = unsafe.Sizeof([1]C.RKLLMPromptCacheParam{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RKLLMPromptCacheParam) Ref() *C.RKLLMPromptCacheParam {
	if x == nil {
		return nil
	}
	return x.refe52ea782
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RKLLMPromptCacheParam) Free() {
	if x != nil && x.allocse52ea782 != nil {
		x.allocse52ea782.(*cgoAllocMap).Free()
		x.refe52ea782 = nil
	}
}

// NewRKLLMPromptCacheParamRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRKLLMPromptCacheParamRef(ref unsafe.Pointer) *RKLLMPromptCacheParam {
	if ref == nil {
		return nil
	}
	obj := new(RKLLMPromptCacheParam)
	obj.refe52ea782 = (*C.RKLLMPromptCacheParam)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RKLLMPromptCacheParam) PassRef() (*C.RKLLMPromptCacheParam, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe52ea782 != nil {
		return x.refe52ea782, nil
	}
	meme52ea782 := allocRKLLMPromptCacheParamMemory(1)
	refe52ea782 := (*C.RKLLMPromptCacheParam)(meme52ea782)
	allocse52ea782 := new(cgoAllocMap)
	allocse52ea782.Add(meme52ea782)

	var csave_prompt_cache_allocs *cgoAllocMap
	refe52ea782.save_prompt_cache, csave_prompt_cache_allocs = (C.int)(x.Save_prompt_cache), cgoAllocsUnknown
	allocse52ea782.Borrow(csave_prompt_cache_allocs)

	var cprompt_cache_path_allocs *cgoAllocMap
	refe52ea782.prompt_cache_path, cprompt_cache_path_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.Prompt_cache_path)))
	allocse52ea782.Borrow(cprompt_cache_path_allocs)

	x.refe52ea782 = refe52ea782
	x.allocse52ea782 = allocse52ea782
	return refe52ea782, allocse52ea782

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RKLLMPromptCacheParam) PassValue() (C.RKLLMPromptCacheParam, *cgoAllocMap) {
	if x.refe52ea782 != nil {
		return *x.refe52ea782, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RKLLMPromptCacheParam) Deref() {
	if x.refe52ea782 == nil {
		return
	}
	x.Save_prompt_cache = (int32)(x.refe52ea782.save_prompt_cache)
	hxf7a6dff := (*sliceHeader)(unsafe.Pointer(&x.Prompt_cache_path))
	hxf7a6dff.Data = unsafe.Pointer(x.refe52ea782.prompt_cache_path)
	hxf7a6dff.Cap = 0x7fffffff
	// hxf7a6dff.Len = ? x.Prompt_cache_path x.refe52ea782.prompt_cache_path

}

// allocRKLLMInferParamMemory allocates memory for type C.RKLLMInferParam in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRKLLMInferParamMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRKLLMInferParamValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRKLLMInferParamValue = unsafe.Sizeof([1]C.RKLLMInferParam{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSRKLLMLoraParam transforms a sliced Go data structure into plain C format.
func unpackSRKLLMLoraParam(x []RKLLMLoraParam) (unpacked *C.RKLLMLoraParam, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocRKLLMLoraParamMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.RKLLMLoraParam)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.RKLLMLoraParam)(h.Data)
	return
}

// unpackSRKLLMPromptCacheParam transforms a sliced Go data structure into plain C format.
func unpackSRKLLMPromptCacheParam(x []RKLLMPromptCacheParam) (unpacked *C.RKLLMPromptCacheParam, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocRKLLMPromptCacheParamMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.RKLLMPromptCacheParam)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.RKLLMPromptCacheParam)(h.Data)
	return
}

// packSRKLLMLoraParam reads sliced Go data structure out from plain C format.
func packSRKLLMLoraParam(v []RKLLMLoraParam, ptr0 *C.RKLLMLoraParam) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRKLLMLoraParamValue]C.RKLLMLoraParam)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRKLLMLoraParamRef(unsafe.Pointer(&ptr1))
	}
}

// packSRKLLMPromptCacheParam reads sliced Go data structure out from plain C format.
func packSRKLLMPromptCacheParam(v []RKLLMPromptCacheParam, ptr0 *C.RKLLMPromptCacheParam) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRKLLMPromptCacheParamValue]C.RKLLMPromptCacheParam)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRKLLMPromptCacheParamRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RKLLMInferParam) Ref() *C.RKLLMInferParam {
	if x == nil {
		return nil
	}
	return x.ref2c38a8e9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RKLLMInferParam) Free() {
	if x != nil && x.allocs2c38a8e9 != nil {
		x.allocs2c38a8e9.(*cgoAllocMap).Free()
		x.ref2c38a8e9 = nil
	}
}

// NewRKLLMInferParamRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRKLLMInferParamRef(ref unsafe.Pointer) *RKLLMInferParam {
	if ref == nil {
		return nil
	}
	obj := new(RKLLMInferParam)
	obj.ref2c38a8e9 = (*C.RKLLMInferParam)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RKLLMInferParam) PassRef() (*C.RKLLMInferParam, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2c38a8e9 != nil {
		return x.ref2c38a8e9, nil
	}
	mem2c38a8e9 := allocRKLLMInferParamMemory(1)
	ref2c38a8e9 := (*C.RKLLMInferParam)(mem2c38a8e9)
	allocs2c38a8e9 := new(cgoAllocMap)
	allocs2c38a8e9.Add(mem2c38a8e9)

	var cmode_allocs *cgoAllocMap
	ref2c38a8e9.mode, cmode_allocs = (C.RKLLMInferMode)(x.Mode), cgoAllocsUnknown
	allocs2c38a8e9.Borrow(cmode_allocs)

	var clora_params_allocs *cgoAllocMap
	ref2c38a8e9.lora_params, clora_params_allocs = unpackSRKLLMLoraParam(x.Lora_params)
	allocs2c38a8e9.Borrow(clora_params_allocs)

	var cprompt_cache_params_allocs *cgoAllocMap
	ref2c38a8e9.prompt_cache_params, cprompt_cache_params_allocs = unpackSRKLLMPromptCacheParam(x.Prompt_cache_params)
	allocs2c38a8e9.Borrow(cprompt_cache_params_allocs)

	var ckeep_history_allocs *cgoAllocMap
	ref2c38a8e9.keep_history, ckeep_history_allocs = (C.int)(x.Keep_history), cgoAllocsUnknown
	allocs2c38a8e9.Borrow(ckeep_history_allocs)

	x.ref2c38a8e9 = ref2c38a8e9
	x.allocs2c38a8e9 = allocs2c38a8e9
	return ref2c38a8e9, allocs2c38a8e9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RKLLMInferParam) PassValue() (C.RKLLMInferParam, *cgoAllocMap) {
	if x.ref2c38a8e9 != nil {
		return *x.ref2c38a8e9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RKLLMInferParam) Deref() {
	if x.ref2c38a8e9 == nil {
		return
	}
	x.Mode = (RKLLMInferMode)(x.ref2c38a8e9.mode)
	packSRKLLMLoraParam(x.Lora_params, x.ref2c38a8e9.lora_params)
	packSRKLLMPromptCacheParam(x.Prompt_cache_params, x.ref2c38a8e9.prompt_cache_params)
	x.Keep_history = (int32)(x.ref2c38a8e9.keep_history)
}

// allocRKLLMResultLastHiddenLayerMemory allocates memory for type C.RKLLMResultLastHiddenLayer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRKLLMResultLastHiddenLayerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRKLLMResultLastHiddenLayerValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRKLLMResultLastHiddenLayerValue = unsafe.Sizeof([1]C.RKLLMResultLastHiddenLayer{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RKLLMResultLastHiddenLayer) Ref() *C.RKLLMResultLastHiddenLayer {
	if x == nil {
		return nil
	}
	return x.ref30c701cb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RKLLMResultLastHiddenLayer) Free() {
	if x != nil && x.allocs30c701cb != nil {
		x.allocs30c701cb.(*cgoAllocMap).Free()
		x.ref30c701cb = nil
	}
}

// NewRKLLMResultLastHiddenLayerRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRKLLMResultLastHiddenLayerRef(ref unsafe.Pointer) *RKLLMResultLastHiddenLayer {
	if ref == nil {
		return nil
	}
	obj := new(RKLLMResultLastHiddenLayer)
	obj.ref30c701cb = (*C.RKLLMResultLastHiddenLayer)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RKLLMResultLastHiddenLayer) PassRef() (*C.RKLLMResultLastHiddenLayer, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref30c701cb != nil {
		return x.ref30c701cb, nil
	}
	mem30c701cb := allocRKLLMResultLastHiddenLayerMemory(1)
	ref30c701cb := (*C.RKLLMResultLastHiddenLayer)(mem30c701cb)
	allocs30c701cb := new(cgoAllocMap)
	allocs30c701cb.Add(mem30c701cb)

	var chidden_states_allocs *cgoAllocMap
	ref30c701cb.hidden_states, chidden_states_allocs = copyPFloatBytes((*sliceHeader)(unsafe.Pointer(&x.Hidden_states)))
	allocs30c701cb.Borrow(chidden_states_allocs)

	var cembd_size_allocs *cgoAllocMap
	ref30c701cb.embd_size, cembd_size_allocs = (C.int)(x.Embd_size), cgoAllocsUnknown
	allocs30c701cb.Borrow(cembd_size_allocs)

	var cnum_tokens_allocs *cgoAllocMap
	ref30c701cb.num_tokens, cnum_tokens_allocs = (C.int)(x.Num_tokens), cgoAllocsUnknown
	allocs30c701cb.Borrow(cnum_tokens_allocs)

	x.ref30c701cb = ref30c701cb
	x.allocs30c701cb = allocs30c701cb
	return ref30c701cb, allocs30c701cb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RKLLMResultLastHiddenLayer) PassValue() (C.RKLLMResultLastHiddenLayer, *cgoAllocMap) {
	if x.ref30c701cb != nil {
		return *x.ref30c701cb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RKLLMResultLastHiddenLayer) Deref() {
	if x.ref30c701cb == nil {
		return
	}
	hxfe48d67 := (*sliceHeader)(unsafe.Pointer(&x.Hidden_states))
	hxfe48d67.Data = unsafe.Pointer(x.ref30c701cb.hidden_states)
	hxfe48d67.Cap = 0x7fffffff
	// hxfe48d67.Len = ? x.Hidden_states x.ref30c701cb.hidden_states

	x.Embd_size = (int32)(x.ref30c701cb.embd_size)
	x.Num_tokens = (int32)(x.ref30c701cb.num_tokens)
}

// allocRKLLMResultLogitsMemory allocates memory for type C.RKLLMResultLogits in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRKLLMResultLogitsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRKLLMResultLogitsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRKLLMResultLogitsValue = unsafe.Sizeof([1]C.RKLLMResultLogits{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RKLLMResultLogits) Ref() *C.RKLLMResultLogits {
	if x == nil {
		return nil
	}
	return x.reff4388bea
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RKLLMResultLogits) Free() {
	if x != nil && x.allocsf4388bea != nil {
		x.allocsf4388bea.(*cgoAllocMap).Free()
		x.reff4388bea = nil
	}
}

// NewRKLLMResultLogitsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRKLLMResultLogitsRef(ref unsafe.Pointer) *RKLLMResultLogits {
	if ref == nil {
		return nil
	}
	obj := new(RKLLMResultLogits)
	obj.reff4388bea = (*C.RKLLMResultLogits)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RKLLMResultLogits) PassRef() (*C.RKLLMResultLogits, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff4388bea != nil {
		return x.reff4388bea, nil
	}
	memf4388bea := allocRKLLMResultLogitsMemory(1)
	reff4388bea := (*C.RKLLMResultLogits)(memf4388bea)
	allocsf4388bea := new(cgoAllocMap)
	allocsf4388bea.Add(memf4388bea)

	var clogits_allocs *cgoAllocMap
	reff4388bea.logits, clogits_allocs = copyPFloatBytes((*sliceHeader)(unsafe.Pointer(&x.Logits)))
	allocsf4388bea.Borrow(clogits_allocs)

	var cvocab_size_allocs *cgoAllocMap
	reff4388bea.vocab_size, cvocab_size_allocs = (C.int)(x.Vocab_size), cgoAllocsUnknown
	allocsf4388bea.Borrow(cvocab_size_allocs)

	var cnum_tokens_allocs *cgoAllocMap
	reff4388bea.num_tokens, cnum_tokens_allocs = (C.int)(x.Num_tokens), cgoAllocsUnknown
	allocsf4388bea.Borrow(cnum_tokens_allocs)

	x.reff4388bea = reff4388bea
	x.allocsf4388bea = allocsf4388bea
	return reff4388bea, allocsf4388bea

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RKLLMResultLogits) PassValue() (C.RKLLMResultLogits, *cgoAllocMap) {
	if x.reff4388bea != nil {
		return *x.reff4388bea, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RKLLMResultLogits) Deref() {
	if x.reff4388bea == nil {
		return
	}
	hxf4171bf := (*sliceHeader)(unsafe.Pointer(&x.Logits))
	hxf4171bf.Data = unsafe.Pointer(x.reff4388bea.logits)
	hxf4171bf.Cap = 0x7fffffff
	// hxf4171bf.Len = ? x.Logits x.reff4388bea.logits

	x.Vocab_size = (int32)(x.reff4388bea.vocab_size)
	x.Num_tokens = (int32)(x.reff4388bea.num_tokens)
}

// allocRKLLMResultMemory allocates memory for type C.RKLLMResult in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRKLLMResultMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRKLLMResultValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRKLLMResultValue = unsafe.Sizeof([1]C.RKLLMResult{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RKLLMResult) Ref() *C.RKLLMResult {
	if x == nil {
		return nil
	}
	return x.refeb437fd0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RKLLMResult) Free() {
	if x != nil && x.allocseb437fd0 != nil {
		x.allocseb437fd0.(*cgoAllocMap).Free()
		x.refeb437fd0 = nil
	}
}

// NewRKLLMResultRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRKLLMResultRef(ref unsafe.Pointer) *RKLLMResult {
	if ref == nil {
		return nil
	}
	obj := new(RKLLMResult)
	obj.refeb437fd0 = (*C.RKLLMResult)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RKLLMResult) PassRef() (*C.RKLLMResult, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeb437fd0 != nil {
		return x.refeb437fd0, nil
	}
	memeb437fd0 := allocRKLLMResultMemory(1)
	refeb437fd0 := (*C.RKLLMResult)(memeb437fd0)
	allocseb437fd0 := new(cgoAllocMap)
	allocseb437fd0.Add(memeb437fd0)

	var ctext_allocs *cgoAllocMap
	refeb437fd0.text, ctext_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.Text)))
	allocseb437fd0.Borrow(ctext_allocs)

	var ctoken_id_allocs *cgoAllocMap
	refeb437fd0.token_id, ctoken_id_allocs = (C.int32_t)(x.Token_id), cgoAllocsUnknown
	allocseb437fd0.Borrow(ctoken_id_allocs)

	var clast_hidden_layer_allocs *cgoAllocMap
	refeb437fd0.last_hidden_layer, clast_hidden_layer_allocs = x.Last_hidden_layer.PassValue()
	allocseb437fd0.Borrow(clast_hidden_layer_allocs)

	var clogits_allocs *cgoAllocMap
	refeb437fd0.logits, clogits_allocs = x.Logits.PassValue()
	allocseb437fd0.Borrow(clogits_allocs)

	x.refeb437fd0 = refeb437fd0
	x.allocseb437fd0 = allocseb437fd0
	return refeb437fd0, allocseb437fd0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RKLLMResult) PassValue() (C.RKLLMResult, *cgoAllocMap) {
	if x.refeb437fd0 != nil {
		return *x.refeb437fd0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RKLLMResult) Deref() {
	if x.refeb437fd0 == nil {
		return
	}
	hxf058b18 := (*sliceHeader)(unsafe.Pointer(&x.Text))
	hxf058b18.Data = unsafe.Pointer(x.refeb437fd0.text)
	hxf058b18.Cap = 0x7fffffff
	// hxf058b18.Len = ? x.Text x.refeb437fd0.text

	x.Token_id = (int32)(x.refeb437fd0.token_id)
	x.Last_hidden_layer = *NewRKLLMResultLastHiddenLayerRef(unsafe.Pointer(&x.refeb437fd0.last_hidden_layer))
	x.Logits = *NewRKLLMResultLogitsRef(unsafe.Pointer(&x.refeb437fd0.logits))
}

// packSRKLLMResult reads sliced Go data structure out from plain C format.
func packSRKLLMResult(v []RKLLMResult, ptr0 *C.RKLLMResult) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRKLLMResultValue]C.RKLLMResult)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRKLLMResultRef(unsafe.Pointer(&ptr1))
	}
}

func (x LLMResultCallback) PassRef() (ref *C.LLMResultCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if lLMResultCallback3439A4ADFunc == nil {
		lLMResultCallback3439A4ADFunc = x
	}
	return (*C.LLMResultCallback)(C.LLMResultCallback_3439a4ad), nil
}

func (x LLMResultCallback) PassValue() (ref C.LLMResultCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if lLMResultCallback3439A4ADFunc == nil {
		lLMResultCallback3439A4ADFunc = x
	}
	return (C.LLMResultCallback)(C.LLMResultCallback_3439a4ad), nil
}

func NewLLMResultCallbackRef(ref unsafe.Pointer) *LLMResultCallback {
	return (*LLMResultCallback)(ref)
}

//export lLMResultCallback3439A4AD
func lLMResultCallback3439A4AD(cresult *C.RKLLMResult, cuserdata unsafe.Pointer, cstate C.LLMCallState) {
	if lLMResultCallback3439A4ADFunc != nil {
		var result3439a4ad []RKLLMResult
		packSRKLLMResult(result3439a4ad, cresult)
		userdata3439a4ad := (unsafe.Pointer)(unsafe.Pointer(cuserdata))
		state3439a4ad := (LLMCallState)(cstate)
		lLMResultCallback3439A4ADFunc(result3439a4ad, userdata3439a4ad, state3439a4ad)
		return
	}
	panic("callback func has not been set (race?)")
}

var lLMResultCallback3439A4ADFunc LLMResultCallback

// copyPLLMHandleBytes copies the data from Go slice as *C.LLMHandle.
func copyPLLMHandleBytes(slice *sliceHeader) (*C.LLMHandle, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfLLMHandleValue) * slice.Len,
		Cap:  int(sizeOfLLMHandleValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.LLMHandle)(mem0), allocs
}

// allocLLMHandleMemory allocates memory for type C.LLMHandle in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLLMHandleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLLMHandleValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfLLMHandleValue = unsafe.Sizeof([1]C.LLMHandle{})

// unpackArgSRKLLMParam transforms a sliced Go data structure into plain C format.
func unpackArgSRKLLMParam(x []RKLLMParam) (unpacked *C.RKLLMParam, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocRKLLMParamMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.RKLLMParam)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.RKLLMParam)(h.Data)
	return
}

// packSRKLLMParam reads sliced Go data structure out from plain C format.
func packSRKLLMParam(v []RKLLMParam, ptr0 *C.RKLLMParam) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRKLLMParamValue]C.RKLLMParam)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRKLLMParamRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSRKLLMLoraAdapter transforms a sliced Go data structure into plain C format.
func unpackArgSRKLLMLoraAdapter(x []RKLLMLoraAdapter) (unpacked *C.RKLLMLoraAdapter, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocRKLLMLoraAdapterMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.RKLLMLoraAdapter)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.RKLLMLoraAdapter)(h.Data)
	return
}

// packSRKLLMLoraAdapter reads sliced Go data structure out from plain C format.
func packSRKLLMLoraAdapter(v []RKLLMLoraAdapter, ptr0 *C.RKLLMLoraAdapter) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRKLLMLoraAdapterValue]C.RKLLMLoraAdapter)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRKLLMLoraAdapterRef(unsafe.Pointer(&ptr1))
	}
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	str = safeString(str)
	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// unpackArgSRKLLMInput transforms a sliced Go data structure into plain C format.
func unpackArgSRKLLMInput(x []RKLLMInput) (unpacked *C.RKLLMInput, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocRKLLMInputMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.RKLLMInput)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.RKLLMInput)(h.Data)
	return
}

// packSRKLLMInput reads sliced Go data structure out from plain C format.
func packSRKLLMInput(v []RKLLMInput, ptr0 *C.RKLLMInput) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRKLLMInputValue]C.RKLLMInput)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRKLLMInputRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSRKLLMInferParam transforms a sliced Go data structure into plain C format.
func unpackArgSRKLLMInferParam(x []RKLLMInferParam) (unpacked *C.RKLLMInferParam, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocRKLLMInferParamMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.RKLLMInferParam)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.RKLLMInferParam)(h.Data)
	return
}

// packSRKLLMInferParam reads sliced Go data structure out from plain C format.
func packSRKLLMInferParam(v []RKLLMInferParam, ptr0 *C.RKLLMInferParam) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRKLLMInferParamValue]C.RKLLMInferParam)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRKLLMInferParamRef(unsafe.Pointer(&ptr1))
	}
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}
